const m={USER_SETTINGS:"promptpilot_user_settings",PROMPT_HISTORY:"promptpilot_prompt_history",USAGE_ANALYTICS:"promptpilot_usage_analytics",MONTHLY_USAGE:"promptpilot_monthly_usage"},w={selectedIntent:"general",usageCount:0,subscriptionStatus:"free",lastResetDate:new Date,monthlyLimit:20,installDate:new Date,lastActiveDate:new Date},f={totalImprovements:0,improvementsThisMonth:0,averagePromptLength:0,averageImprovementLength:0,mostUsedIntent:"general",mostUsedPlatform:"unknown",averageProcessingTime:0,successRate:100,lastCalculated:new Date};class p{static async getUserSettings(){try{const e=(await chrome.storage.local.get(m.USER_SETTINGS))[m.USER_SETTINGS];if(!e){const r={...w,installDate:new Date,lastActiveDate:new Date};return await this.saveUserSettings(r),r}return{...e,lastResetDate:new Date(e.lastResetDate),installDate:new Date(e.installDate),lastActiveDate:new Date(e.lastActiveDate)}}catch(t){return console.error("Error getting user settings:",t),w}}static async saveUserSettings(t){try{await chrome.storage.local.set({[m.USER_SETTINGS]:t})}catch(e){throw console.error("Error saving user settings:",e),e}}static async updateUserSettings(t){try{const r={...await this.getUserSettings(),...t,lastActiveDate:new Date};return await this.saveUserSettings(r),r}catch(e){throw console.error("Error updating user settings:",e),e}}static async hasReachedLimit(){try{const t=await this.getUserSettings();if(t.subscriptionStatus==="premium"||t.subscriptionStatus==="lifetime")return!1;const e=new Date,r=new Date(t.lastResetDate);return(e.getFullYear()-r.getFullYear())*12+(e.getMonth()-r.getMonth())>=1?(await this.updateUserSettings({usageCount:0,lastResetDate:new Date(e.getFullYear(),e.getMonth(),1)}),!1):t.usageCount>=t.monthlyLimit}catch(t){return console.error("Error checking usage limit:",t),!1}}static async getRemainingImprovements(){try{const t=await this.getUserSettings();return t.subscriptionStatus==="premium"||t.subscriptionStatus==="lifetime"?1/0:Math.max(0,t.monthlyLimit-t.usageCount)}catch(t){return console.error("Error getting remaining improvements:",t),0}}static getNextResetDate(){const t=new Date;return new Date(t.getFullYear(),t.getMonth()+1,1)}static async incrementUsage(){try{const t=await this.getUserSettings();await this.updateUserSettings({usageCount:t.usageCount+1})}catch(t){throw console.error("Error incrementing usage:",t),t}}static async savePromptImprovement(t){try{const r=(await chrome.storage.local.get(m.PROMPT_HISTORY))[m.PROMPT_HISTORY]||[];r.push(t);const a=1e3;r.length>a&&r.splice(0,r.length-a),await chrome.storage.local.set({[m.PROMPT_HISTORY]:r}),await this.updateAnalytics()}catch(e){throw console.error("Error saving prompt improvement:",e),e}}static async getPromptHistory(t){try{const u=((await chrome.storage.local.get(m.PROMPT_HISTORY))[m.PROMPT_HISTORY]||[]).map(i=>({...i,timestamp:new Date(i.timestamp)})).sort((i,y)=>y.timestamp.getTime()-i.timestamp.getTime());return t?u.slice(0,t):u}catch(e){return console.error("Error getting prompt history:",e),[]}}static async updateAnalytics(){try{const t=await this.getPromptHistory(),e=new Date,r=e.getMonth(),a=e.getFullYear(),u=t.filter(s=>{const n=new Date(s.timestamp);return n.getMonth()===r&&n.getFullYear()===a}),i=t.length,y=u.length,c=t.filter(s=>s.success),d=i>0?c.length/i*100:100,E=i>0?t.reduce((s,n)=>s+n.originalLength,0)/i:0,l=i>0?t.reduce((s,n)=>s+n.improvedLength,0)/i:0,h=i>0?t.reduce((s,n)=>s+n.processingTimeMs,0)/i:0,g=t.reduce((s,n)=>(s[n.intent]=(s[n.intent]||0)+1,s),{}),S=t.reduce((s,n)=>(s[n.platform]=(s[n.platform]||0)+1,s),{}),v=Object.keys(g).reduce((s,n)=>g[s]>g[n]?s:n,"general"),D=Object.keys(S).reduce((s,n)=>S[s]>S[n]?s:n,"unknown"),b={totalImprovements:i,improvementsThisMonth:y,averagePromptLength:E,averageImprovementLength:l,mostUsedIntent:v,mostUsedPlatform:D,averageProcessingTime:h,successRate:d,lastCalculated:e};await chrome.storage.local.set({[m.USAGE_ANALYTICS]:b})}catch(t){console.error("Error updating analytics:",t)}}static async getUsageAnalytics(){try{const e=(await chrome.storage.local.get(m.USAGE_ANALYTICS))[m.USAGE_ANALYTICS];return e?{...e,lastCalculated:new Date(e.lastCalculated)}:f}catch(t){return console.error("Error getting usage analytics:",t),f}}static async clearAllData(){try{await chrome.storage.local.remove([m.USER_SETTINGS,m.PROMPT_HISTORY,m.USAGE_ANALYTICS,m.MONTHLY_USAGE])}catch(t){throw console.error("Error clearing analytics data:",t),t}}static async exportData(){try{const[t,e,r]=await Promise.all([this.getUserSettings(),this.getPromptHistory(),this.getUsageAnalytics()]);return{userSettings:t,promptHistory:e,usageAnalytics:r}}catch(t){throw console.error("Error exporting data:",t),t}}}const _="http://localhost:4001";let P=!1;function I(){P||(console.log("PromptPilot background service worker initializing..."),T().then(o=>{console.log(`Backend health check: ${o?"OK":"Failed"}`)}).catch(o=>{console.error("Backend health check error:",o)}),P=!0,console.log("PromptPilot background service worker initialized"))}async function T(){try{return(await(await fetch(`${_}/health`,{method:"GET",headers:{"Content-Type":"application/json"}})).json()).status==="ok"}catch(o){return console.error("Error checking backend health:",o),!1}}chrome.runtime.onMessage.addListener((o,t,e)=>{if(console.log("Background received message:",o.type,"from",t.tab?"content script":"popup"),I(),o.type==="IMPROVE_AND_REPLACE"){const r=o.text,a=o.intent||"general",u=o.platform||"unknown";return console.log("IMPROVE_AND_REPLACE: Received text to improve, length:",r.length),console.log("IMPROVE_AND_REPLACE: Sender tab:",t.tab?t.tab.id:"undefined"),p.hasReachedLimit().then(async i=>{if(i){const c=await p.getRemainingImprovements(),d=await p.getUserSettings();console.log("User has reached monthly limit"),t.tab&&typeof t.tab.id=="number"&&chrome.tabs.sendMessage(t.tab.id,{type:"USAGE_LIMIT_REACHED",remaining:c,limit:d.monthlyLimit,subscriptionStatus:d.subscriptionStatus}),e({status:"limit_reached",remaining:c,limit:d.monthlyLimit});return}e({status:"processing"}),console.log("IMPROVE_AND_REPLACE: Sent processing response to content script");const y=Date.now();A(r).then(async c=>{const E=Date.now()-y;console.log("Successfully improved prompt, sending for replacement"),console.log("Improved prompt:",c.substring(0,100)+"...");try{await p.incrementUsage();const l={id:`${Date.now()}-${Math.random().toString(36).substr(2,9)}`,originalPrompt:r,improvedPrompt:c,intent:a,timestamp:new Date,modelUsed:"backend-api",originalLength:r.length,improvedLength:c.length,platform:u,processingTimeMs:E,success:!0};await p.savePromptImprovement(l),console.log("Analytics tracked successfully");const h=await p.getRemainingImprovements(),g=await p.getUserSettings();g.subscriptionStatus==="free"&&(h===4||h===1)&&t.tab&&typeof t.tab.id=="number"&&chrome.tabs.sendMessage(t.tab.id,{type:"USAGE_WARNING",remaining:h,limit:g.monthlyLimit,subscriptionStatus:g.subscriptionStatus})}catch(l){console.error("Error tracking analytics:",l)}if(t.tab&&typeof t.tab.id=="number"){const l=t.tab.id;console.log("Sending improved text to tab ID:",l),chrome.tabs.sendMessage(l,{type:"IMPROVED_TEXT_FOR_REPLACEMENT",text:c},h=>{const g=chrome.runtime.lastError;g?(console.error("Error sending improved text to content script:",g.message),setTimeout(()=>{chrome.tabs.sendMessage(l,{type:"IMPROVED_TEXT_FOR_REPLACEMENT",text:c},S=>{const v=chrome.runtime.lastError;v?console.error("Retry failed, error sending improved text:",v.message):console.log("Retry successful, content script updated text:",S)})},500)):console.log("Content script updated text successfully:",h)})}else console.error("Cannot send improved text: sender.tab or sender.tab.id is undefined",t)}).catch(async c=>{const E=Date.now()-y;console.error("Error improving prompt:",c),console.error("Full error object:",JSON.stringify(c,Object.getOwnPropertyNames(c)));try{const l={id:`${Date.now()}-${Math.random().toString(36).substr(2,9)}`,originalPrompt:r,improvedPrompt:"",intent:a,timestamp:new Date,modelUsed:"backend-api",originalLength:r.length,improvedLength:0,platform:u,processingTimeMs:E,success:!1,errorMessage:c.message||"Unknown error"};await p.savePromptImprovement(l),console.log("Failed improvement analytics tracked")}catch(l){console.error("Error tracking failed improvement analytics:",l)}if(t.tab&&typeof t.tab.id=="number"){const l=t.tab.id;chrome.tabs.sendMessage(l,{type:"IMPROVEMENT_ERROR",error:c.message||"Failed to improve prompt. Please try again."},h=>{const g=chrome.runtime.lastError;g&&console.error("Error sending error to content script:",g.message)})}else console.error("Cannot send error: sender.tab or sender.tab.id is undefined",t)})}).catch(i=>{console.error("Error checking usage limits:",i),e({status:"error",error:"Failed to check usage limits"})}),!0}if(o.type==="CAPTURED_TEXT"){console.log("Received CAPTURED_TEXT, forwarding to popup");try{chrome.storage.session.set({lastCapturedText:o.text},()=>{console.log("Saved captured text to session storage")})}catch(r){console.error("Error saving to session storage:",r)}try{chrome.runtime.sendMessage(o,r=>{const a=chrome.runtime.lastError;console.log(a?"Note: Popup may not be open to receive text":"Text forwarded to popup")})}catch(r){console.error("Error forwarding message:",r)}return e({status:"received"}),!0}if(o.type==="CHECK_BACKEND")return T().then(r=>{e({status:r?"healthy":"unhealthy"})}).catch(r=>{e({status:"error",error:r.message})}),!0;if(o.type==="GET_USER_SETTINGS")return p.getUserSettings().then(r=>{e({status:"success",data:r})}).catch(r=>{e({status:"error",error:r.message})}),!0;if(o.type==="GET_USAGE_ANALYTICS")return p.getUsageAnalytics().then(r=>{e({status:"success",data:r})}).catch(r=>{e({status:"error",error:r.message})}),!0;if(o.type==="GET_PROMPT_HISTORY"){const r=o.limit||50;return p.getPromptHistory(r).then(a=>{e({status:"success",data:a})}).catch(a=>{e({status:"error",error:a.message})}),!0}return o.type==="UPDATE_USER_SETTINGS"?(p.updateUserSettings(o.updates).then(r=>{e({status:"success",data:r})}).catch(r=>{e({status:"error",error:r.message})}),!0):o.type==="GET_REMAINING_IMPROVEMENTS"?(p.getRemainingImprovements().then(r=>{e({status:"success",data:r})}).catch(r=>{e({status:"error",error:r.message})}),!0):(console.log("Unhandled message type:",o.type),e({status:"unhandled_message_type"}),!0)});async function A(o){console.log("improvePrompt: Starting prompt improvement for text of length:",o.length);try{console.log("improvePrompt: Checking backend health");const t=await T();if(console.log("improvePrompt: Backend health check result:",t),!t){console.log("improvePrompt: Backend not healthy, using demo mode");const e=`${o}

[DEMO MODE] This is a simulated improved prompt. In production, this would be an AI-enhanced version of your text.`;try{chrome.storage.session.set({lastImprovedText:e}),console.log("improvePrompt: Saved demo improved text to session storage")}catch(r){console.error("improvePrompt: Error saving improved text to session storage:",r)}return e}console.log("improvePrompt: Sending text to backend for improvement");try{const e=await fetch(`${_}/improve`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({prompt:o})});if(console.log("improvePrompt: Received response from backend:",e.status,e.statusText),!e.ok){const u=(await e.json().catch(()=>({}))).error||`Server returned ${e.status}: ${e.statusText}`;throw console.error("improvePrompt: Backend returned error:",u),new Error(u)}const r=await e.json().catch(()=>{throw new Error("Failed to parse backend response as JSON")});if(console.log("improvePrompt: Successfully parsed JSON response from backend"),!r.improvedPrompt)throw console.error("improvePrompt: Backend response missing improvedPrompt field:",r),new Error("Backend response missing improvedPrompt field");try{chrome.storage.session.set({lastImprovedText:r.improvedPrompt}),console.log("improvePrompt: Saved improved text to session storage")}catch(a){console.error("improvePrompt: Error saving improved text to session storage:",a)}return r.improvedPrompt}catch(e){throw console.error("improvePrompt: Error in fetch operation:",e),e}}catch(t){throw console.error("improvePrompt: Error in improvePrompt:",t),new Error(`Failed to improve prompt: ${t.message}`)}}I();chrome.runtime.onConnect.addListener(o=>{console.log("Connection established with",o.name),o.onMessage.addListener(t=>{console.log("Received port message:",t)}),o.onDisconnect.addListener(()=>{console.log("Port disconnected:",o.name)})});
