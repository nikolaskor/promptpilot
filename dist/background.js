const g={USER_SETTINGS:"promptpilot_user_settings",PROMPT_HISTORY:"promptpilot_prompt_history",USAGE_ANALYTICS:"promptpilot_usage_analytics",MONTHLY_USAGE:"promptpilot_monthly_usage"},w={selectedIntent:"general",usageCount:0,subscriptionStatus:"free",lastResetDate:new Date,monthlyLimit:20,installDate:new Date,lastActiveDate:new Date},T={totalImprovements:0,improvementsThisMonth:0,averagePromptLength:0,averageImprovementLength:0,mostUsedIntent:"general",mostUsedPlatform:"unknown",averageProcessingTime:0,successRate:100,lastCalculated:new Date};class u{static async getUserSettings(){try{const e=(await chrome.storage.local.get(g.USER_SETTINGS))[g.USER_SETTINGS];if(!e){const r={...w,installDate:new Date,lastActiveDate:new Date};return await this.saveUserSettings(r),r}return{...e,lastResetDate:new Date(e.lastResetDate),installDate:new Date(e.installDate),lastActiveDate:new Date(e.lastActiveDate)}}catch(t){return console.error("Error getting user settings:",t),w}}static async saveUserSettings(t){try{await chrome.storage.local.set({[g.USER_SETTINGS]:t})}catch(e){throw console.error("Error saving user settings:",e),e}}static async updateUserSettings(t){try{const r={...await this.getUserSettings(),...t,lastActiveDate:new Date};return await this.saveUserSettings(r),r}catch(e){throw console.error("Error updating user settings:",e),e}}static async hasReachedLimit(){try{const t=await this.getUserSettings();if(t.subscriptionStatus==="premium"||t.subscriptionStatus==="lifetime")return!1;const e=new Date,r=new Date(t.lastResetDate);return(e.getFullYear()-r.getFullYear())*12+(e.getMonth()-r.getMonth())>=1?(await this.updateUserSettings({usageCount:0,lastResetDate:new Date(e.getFullYear(),e.getMonth(),1)}),!1):t.usageCount>=t.monthlyLimit}catch(t){return console.error("Error checking usage limit:",t),!1}}static async getRemainingImprovements(){try{const t=await this.getUserSettings();return t.subscriptionStatus==="premium"||t.subscriptionStatus==="lifetime"?1/0:Math.max(0,t.monthlyLimit-t.usageCount)}catch(t){return console.error("Error getting remaining improvements:",t),0}}static getNextResetDate(){const t=new Date;return new Date(t.getFullYear(),t.getMonth()+1,1)}static async incrementUsage(){try{const t=await this.getUserSettings();await this.updateUserSettings({usageCount:t.usageCount+1})}catch(t){throw console.error("Error incrementing usage:",t),t}}static async savePromptImprovement(t){try{const r=(await chrome.storage.local.get(g.PROMPT_HISTORY))[g.PROMPT_HISTORY]||[];r.push(t);const n=1e3;r.length>n&&r.splice(0,r.length-n),await chrome.storage.local.set({[g.PROMPT_HISTORY]:r}),await this.updateAnalytics()}catch(e){throw console.error("Error saving prompt improvement:",e),e}}static async getPromptHistory(t){try{const c=((await chrome.storage.local.get(g.PROMPT_HISTORY))[g.PROMPT_HISTORY]||[]).map(a=>({...a,timestamp:new Date(a.timestamp)})).sort((a,h)=>h.timestamp.getTime()-a.timestamp.getTime());return t?c.slice(0,t):c}catch(e){return console.error("Error getting prompt history:",e),[]}}static async updateAnalytics(){try{const t=await this.getPromptHistory(),e=new Date,r=e.getMonth(),n=e.getFullYear(),c=t.filter(s=>{const i=new Date(s.timestamp);return i.getMonth()===r&&i.getFullYear()===n}),a=t.length,h=c.length,l=t.filter(s=>s.success),y=a>0?l.length/a*100:100,E=a>0?t.reduce((s,i)=>s+i.originalLength,0)/a:0,m=a>0?t.reduce((s,i)=>s+i.improvedLength,0)/a:0,d=a>0?t.reduce((s,i)=>s+i.processingTimeMs,0)/a:0,p=t.reduce((s,i)=>(s[i.intent]=(s[i.intent]||0)+1,s),{}),S=t.reduce((s,i)=>(s[i.platform]=(s[i.platform]||0)+1,s),{}),v=Object.keys(p).reduce((s,i)=>p[s]>p[i]?s:i,"general"),_=Object.keys(S).reduce((s,i)=>S[s]>S[i]?s:i,"unknown"),D={totalImprovements:a,improvementsThisMonth:h,averagePromptLength:E,averageImprovementLength:m,mostUsedIntent:v,mostUsedPlatform:_,averageProcessingTime:d,successRate:y,lastCalculated:e};await chrome.storage.local.set({[g.USAGE_ANALYTICS]:D})}catch(t){console.error("Error updating analytics:",t)}}static async getUsageAnalytics(){try{const e=(await chrome.storage.local.get(g.USAGE_ANALYTICS))[g.USAGE_ANALYTICS];return e?{...e,lastCalculated:new Date(e.lastCalculated)}:T}catch(t){return console.error("Error getting usage analytics:",t),T}}static async clearAllData(){try{await chrome.storage.local.remove([g.USER_SETTINGS,g.PROMPT_HISTORY,g.USAGE_ANALYTICS,g.MONTHLY_USAGE])}catch(t){throw console.error("Error clearing analytics data:",t),t}}static async exportData(){try{const[t,e,r]=await Promise.all([this.getUserSettings(),this.getPromptHistory(),this.getUsageAnalytics()]);return{userSettings:t,promptHistory:e,usageAnalytics:r}}catch(t){throw console.error("Error exporting data:",t),t}}}const I="http://localhost:4001";let P=!1;function b(){P||(console.log("PromptPilot background service worker initializing..."),f().then(o=>{console.log(`Backend health check: ${o?"OK":"Failed"}`)}).catch(o=>{console.error("Backend health check error:",o)}),P=!0,console.log("PromptPilot background service worker initialized"))}async function f(){try{return(await(await fetch(`${I}/health`,{method:"GET",headers:{"Content-Type":"application/json"}})).json()).status==="ok"}catch(o){return console.error("Error checking backend health:",o),!1}}chrome.runtime.onMessage.addListener((o,t,e)=>{if(console.log("Background received message:",o.type,"from",t.tab?"content script":"popup"),b(),o.type==="IMPROVE_AND_REPLACE"){const r=o.text,n=o.intent||"general",c=o.platform||"unknown";return console.log("IMPROVE_AND_REPLACE: Received text to improve, length:",r.length),console.log("IMPROVE_AND_REPLACE: Sender tab:",t.tab?t.tab.id:"undefined"),u.hasReachedLimit().then(async a=>{if(a){const l=await u.getRemainingImprovements(),y=await u.getUserSettings();console.log("User has reached monthly limit"),t.tab&&typeof t.tab.id=="number"&&chrome.tabs.sendMessage(t.tab.id,{type:"USAGE_LIMIT_REACHED",remaining:l,limit:y.monthlyLimit,subscriptionStatus:y.subscriptionStatus}),e({status:"limit_reached",remaining:l,limit:y.monthlyLimit});return}e({status:"processing"}),console.log("IMPROVE_AND_REPLACE: Sent processing response to content script");const h=Date.now();A(r).then(async l=>{const E=Date.now()-h;console.log("Successfully improved prompt, sending for replacement"),console.log("Improved prompt:",l.substring(0,100)+"...");try{await u.incrementUsage();const m={id:`${Date.now()}-${Math.random().toString(36).substr(2,9)}`,originalPrompt:r,improvedPrompt:l,intent:n,timestamp:new Date,modelUsed:"backend-api",originalLength:r.length,improvedLength:l.length,platform:c,processingTimeMs:E,success:!0};await u.savePromptImprovement(m),console.log("Analytics tracked successfully");const d=await u.getRemainingImprovements(),p=await u.getUserSettings();p.subscriptionStatus==="free"&&(d===4||d===1)&&t.tab&&typeof t.tab.id=="number"&&chrome.tabs.sendMessage(t.tab.id,{type:"USAGE_WARNING",remaining:d,limit:p.monthlyLimit,subscriptionStatus:p.subscriptionStatus})}catch(m){console.error("Error tracking analytics:",m)}if(t.tab&&typeof t.tab.id=="number"){const m=t.tab.id;console.log("Sending improved text to tab ID:",m),chrome.tabs.sendMessage(m,{type:"IMPROVED_TEXT_FOR_REPLACEMENT",text:l},d=>{const p=chrome.runtime.lastError;p?(console.error("Error sending improved text to content script:",p.message),setTimeout(()=>{chrome.tabs.sendMessage(m,{type:"IMPROVED_TEXT_FOR_REPLACEMENT",text:l},S=>{const v=chrome.runtime.lastError;v?console.error("Retry failed, error sending improved text:",v.message):console.log("Retry successful, content script updated text:",S)})},500)):console.log("Content script updated text successfully:",d)})}else console.error("Cannot send improved text: sender.tab or sender.tab.id is undefined",t)}).catch(async l=>{const E=Date.now()-h;console.error("Error improving prompt:",l),console.error("Full error object:",JSON.stringify(l,Object.getOwnPropertyNames(l)));try{const m={id:`${Date.now()}-${Math.random().toString(36).substr(2,9)}`,originalPrompt:r,improvedPrompt:"",intent:n,timestamp:new Date,modelUsed:"backend-api",originalLength:r.length,improvedLength:0,platform:c,processingTimeMs:E,success:!1,errorMessage:l.message||"Unknown error"};await u.savePromptImprovement(m),console.log("Failed improvement analytics tracked")}catch(m){console.error("Error tracking failed improvement analytics:",m)}if(t.tab&&typeof t.tab.id=="number"){const m=t.tab.id;chrome.tabs.sendMessage(m,{type:"IMPROVEMENT_ERROR",error:l.message||"Failed to improve prompt. Please try again."},d=>{const p=chrome.runtime.lastError;p&&console.error("Error sending error to content script:",p.message)})}else console.error("Cannot send error: sender.tab or sender.tab.id is undefined",t)})}).catch(a=>{console.error("Error checking usage limits:",a),e({status:"error",error:"Failed to check usage limits"})}),!0}if(o.type==="CAPTURED_TEXT"){console.log("Received CAPTURED_TEXT, forwarding to popup");try{chrome.storage.session.set({lastCapturedText:o.text},()=>{console.log("Saved captured text to session storage")})}catch(r){console.error("Error saving to session storage:",r)}try{chrome.runtime.sendMessage(o,r=>{const n=chrome.runtime.lastError;console.log(n?"Note: Popup may not be open to receive text":"Text forwarded to popup")})}catch(r){console.error("Error forwarding message:",r)}return e({status:"received"}),!0}if(o.type==="CHECK_BACKEND")return f().then(r=>{e({status:r?"healthy":"unhealthy"})}).catch(r=>{e({status:"error",error:r.message})}),!0;if(o.type==="GET_USER_SETTINGS")return u.getUserSettings().then(r=>{e({status:"success",data:r})}).catch(r=>{e({status:"error",error:r.message})}),!0;if(o.type==="GET_USAGE_ANALYTICS")return u.getUsageAnalytics().then(r=>{e({status:"success",data:r})}).catch(r=>{e({status:"error",error:r.message})}),!0;if(o.type==="GET_PROMPT_HISTORY"){const r=o.limit||50;return u.getPromptHistory(r).then(n=>{e({status:"success",data:n})}).catch(n=>{e({status:"error",error:n.message})}),!0}if(o.type==="UPDATE_USER_SETTINGS")return u.updateUserSettings(o.updates).then(r=>{e({status:"success",data:r})}).catch(r=>{e({status:"error",error:r.message})}),!0;if(o.type==="GET_REMAINING_IMPROVEMENTS")return u.getRemainingImprovements().then(r=>{e({status:"success",data:r})}).catch(r=>{e({status:"error",error:r.message})}),!0;if(o.type==="OPEN_CUSTOMER_PORTAL")return console.log("Opening customer portal..."),chrome.storage.local.get(["stripeCustomerId"],async r=>{const n=r.stripeCustomerId;if(!n){console.error("No customer ID found"),e({status:"error",error:"No customer ID found. Please complete a purchase first."});return}try{const c=await fetch("http://localhost:4001/stripe/create-portal",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({customerId:n,returnUrl:chrome.runtime.getURL("index.html")})});if(!c.ok){const l=await c.json();throw new Error(l.error||"Failed to create portal session")}const{url:a,demoMode:h}=await c.json();if(h){console.log("Demo mode: Customer portal not available"),e({status:"error",error:"Customer portal not available in demo mode. Please configure Stripe API keys."});return}chrome.tabs.create({url:a}),e({status:"success"})}catch(c){console.error("Error opening customer portal:",c),e({status:"error",error:c instanceof Error?c.message:"Unknown error"})}}),!0;if(o.type==="OPEN_EXTENSION"){console.log("Opening extension popup..."),t.tab&&t.tab.id&&chrome.tabs.remove(t.tab.id);try{chrome.action.openPopup(),e({status:"success"})}catch(r){console.error("Error opening popup:",r),e({status:"error",error:"Failed to open popup"})}return!0}return console.log("Unhandled message type:",o.type),e({status:"unhandled_message_type"}),!0});async function A(o){console.log("improvePrompt: Starting prompt improvement for text of length:",o.length);try{console.log("improvePrompt: Checking backend health");const t=await f();if(console.log("improvePrompt: Backend health check result:",t),!t){console.log("improvePrompt: Backend not healthy, using demo mode");const e=`${o}

[DEMO MODE] This is a simulated improved prompt. In production, this would be an AI-enhanced version of your text.`;try{chrome.storage.session.set({lastImprovedText:e}),console.log("improvePrompt: Saved demo improved text to session storage")}catch(r){console.error("improvePrompt: Error saving improved text to session storage:",r)}return e}console.log("improvePrompt: Sending text to backend for improvement");try{const e=await fetch(`${I}/improve`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({prompt:o})});if(console.log("improvePrompt: Received response from backend:",e.status,e.statusText),!e.ok){const c=(await e.json().catch(()=>({}))).error||`Server returned ${e.status}: ${e.statusText}`;throw console.error("improvePrompt: Backend returned error:",c),new Error(c)}const r=await e.json().catch(()=>{throw new Error("Failed to parse backend response as JSON")});if(console.log("improvePrompt: Successfully parsed JSON response from backend"),!r.improvedPrompt)throw console.error("improvePrompt: Backend response missing improvedPrompt field:",r),new Error("Backend response missing improvedPrompt field");try{chrome.storage.session.set({lastImprovedText:r.improvedPrompt}),console.log("improvePrompt: Saved improved text to session storage")}catch(n){console.error("improvePrompt: Error saving improved text to session storage:",n)}return r.improvedPrompt}catch(e){throw console.error("improvePrompt: Error in fetch operation:",e),e}}catch(t){throw console.error("improvePrompt: Error in improvePrompt:",t),new Error(`Failed to improve prompt: ${t.message}`)}}b();chrome.runtime.onConnect.addListener(o=>{console.log("Connection established with",o.name),o.onMessage.addListener(t=>{console.log("Received port message:",t)}),o.onDisconnect.addListener(()=>{console.log("Port disconnected:",o.name)})});
